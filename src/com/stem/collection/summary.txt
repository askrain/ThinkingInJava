集合类：
包含List、Set、Queue、Map，其中前三个实现了Collection接口，他们本身还是接口。而map可以生成Collection

Set每个值只保存一个对象。Map是可以将两个对象关联起来的关联数组。

泛型和类型安全的容器：
1.编译期检查放到容器中的对象类型
2.当不需要使用索引的时候，也可以使用foreach

Object默认的toString()方法：
GrannySmith@5c647e05
Gala@33909752
Fuji@55f96302
Braeburn@3d4eac69

打印类名+对象散列码的无符号16进制

Collection 一个独立的元素序列，所有元素都服从一条或者多条规则 。List按照插入顺序保存序列，Set不能有重复的
元素。Queue按照排队规则来确定对象产生的顺序（通常与插入的顺序一致） Collection都可以使用foreach遍历

Map 一组成对的键值对对象，可以使用key对象找到value对象

Collection在创建的时候经常会使用向上转型的方案，即转型为对应的接口，这样在需要做修改的时候就会非常方便。
但是也会存在问题
LinkedList包含在List接口中未包含的额外方法
TreeMap 也包含在Map接口中未包含的方法
所以，当使用这些接口方法的时候，不能向上转型

addAll的不同使用问题：

Collection的构造器可以接受另一个Collection，用它来进行初始化，可以使用Arrays.asList()来接受一个数组或者用逗号分隔的、
元素列表（可变参数），将其转换为List。但是这个方法有一个问题就是：
这种数组转化为集合的操作当时，其底层表示还是数组，因此不能调整尺寸，当使用add或者remove的时候，因为操作本身会改变数组尺寸，会报
Unsupported Operation。
另外，Collections的addAll()方法更加灵活，向Arrays.asList()一样，都可以接受可变参数列表
另外Arrays.asList()还有另外一个问题：
类型转换：当一个list规定的保存类型为父类的时候，使用asList来初始化元素可能会遇到编译错误，因为这个方法默认
不能很好的做类型方面的向下校验
Collections的addAll()方法可以解决这个问题，或者可以在Arrays.<和List一样的类型>asList()来解决这个问题

容器的添加作用；
使用容器自带的toString()来打印容器中的元素：
Collection中的元素都用[]来包裹起来。Map中的元素则使用{}包裹起来

fill()可以用到所有的Collection中

ArrayList和LinkedList都是List类型，区别在于执行某些操作时的性能问题。另外LinkedList包含的操作也多余ArrayList

Set
HashSet采用复杂的方式存储元素，因此时最快的获取元素的方式
TreeSet 按照比较结果的升序来保存对象
LinkedHashSet  按照被添加的顺序保存对象

Map 键和值的保存顺序并不是他们的插入顺序，
像HashSet一样，HashMap实现以一种比较快的算法来控制顺序，因此查找速度最快
TreeMap按照比较结果升序保存键值
LinkedHashMap 按照插入顺序保存键值，且保留了HashMap的查找速度





-----------------------------------------------------------------------------------
[List]

ArrayList 查找元素的速度比LinkedList更快。LinkedList的插入和删除速度比ArrayList快


当确定一个元素是否属于某个list，发现某个元素的索引，以及从某个list中移除一个元素时，都会用到equals()
所以必须意识到 List的行为是根据equals()的行为而发生变化的

subList()
containsAll()和顺序没有什么关系
Collections.shuffle()
Collections.sort()

retainAll()是求交集的操作，也是依赖于equals()的操作
removeAll()
set() 常用replace()替代，用来消除歧义
addAll()可以设置插入的位置
isEmpty()
clear()
toArray(length)  必须传入指定的类型，要不然会转换为Object类型的数组

----------------------------------------------------------------------------------




-----------------------------------------------------------------------------------
[迭代器]
Iterator
迭代器统一了对容器的访问方式

java的Iterator只能单项移动，这个Iterator只能用来：
1.使用iterator()要求容器返回一个Iterator，Iterator将准备好返回序列的第一个元素
2.使用next()获取序列的下一个元素
3.使用hasNext()检查序列中是否还有元素
4.使用remove将迭代器新近返回的元素删除

如果遍历的时候不修改list，使用foreach将会更加简洁


ListIterator
是Iterator的子类型，只能用于各种List的访问，且listIterator可以双向移动，可以使用set替换它访问过的
最后一个元素。使用listIterator(n)可以将索引指向list中索引为n的元素

it.nextIndex()   it.previousIndex()

------------------------------------------------------------------------------------

LinkedList
也是实现了List接口，但是比ArrayList在插入和删除的操作上更具有优势
LinkedList还提供了作为栈、队列和双端队列的一些方法

队列Queue
getFirst()和element()都是返回容器第一个元素，但是并不移除，如果容器为空，则报异常。peek()则在为空的时候
返回null。
removeFirst()和remove()都是移除并返回列表的头，列表为空的时候抛出异常。poll()也是移除第一个元素，但容器为
空的时候返回null  removeLast()移除返回列表的最后一个元素

add() addFirst() addLast() 都是将某个元素插入到列表的尾端
offer()是在容器的尾端添加

观察了Queue接口会发现，LinkedList是在LinkedList的基础上增加了 element() offer() peek() poll()
remove()

------------------------------------------------------------------------------------

Stack
栈

LinkedList 也增加了作为作为栈的方法
pop() 移除并返回栈顶元素
peek() 返回栈顶元素

--------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------

Set
不保存重复的元素，所以查找是它最常用的方法，效率比较高的 是HashSet
Set具有和Collection完全一样的接口，因此不具备额外的功能

HashSet 使用了散列函数
TreeSet 将数据存储在红黑树数据结构中
LinkedHashSet 使用了散列函数且维持了元素的插入顺序

常用的contains()用于检查容器中是否 含有某个容器中的元素

Set<String> words=new TreeSet<String>(String.CASE_INSENSITIVE_ORDER);




--------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------

Map

很经典的例子是随机生成100个【0,20）的随机数，统计每个数字出现的次数

常用方法  containsKey() containValue()
Map和Collections一样可以拓展多多维：
Map<String,List<Person>>
Map<String,Map<String,Person>>

keySet()
values()


-----------------------------------------------------------------------------------

Queue

offer() 将一个元素插在队尾，或者返回false
peek() element() 在不移除元素的前提下，返回对头 peek() 不会报错
poll() remove() 移除并返回队头 poll()不报错

PriorityQueue
弹出的元素具有最高的优先级，使用offer()插入元素的时候会被排序，Comparator来修改在这个顺序，使用方法是在它
的构造方法中使用


-----------------------------------------------------------------------------------------

Collection和Iterator

abstract class AbstractCollection<E> implements Collection<E>
public interface Collection<E> extends Iterable<E>  Iterable也是个接口


System.getenv()返回的是一个Map
map.entrySet() 得到的是Map.Entry 类型的entry  entry.getKey() 和entry.getValue()是成对的


-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------

总结：
容器不能持有基本数据类型，但是拆箱和装箱 的机制可以解决这个问题
HashMap 用来快速访问 TreeMap 保持键的排序状态  LinkedHashMap保持了元素的插入顺序，也通过散列提供
了快速访问的能力
set也如此

新程序中不应该使用过时的 Vector HashTable Stack

除了TreeSet以外的Set和Collection有完全一样的接口

Map和Collection之间的唯一重叠就是Map可以使用entrySet() keySet()得到Collection


---------------------------------------------------------------------------------
---------------------------------------------------------------------------------
---------------------------------------------------------------------------------
---------------------------------------------------------------------------------




List接口的三个子接口：
1.ArrayList
2.LinkedList
3.Vector

ArrayList的原理：<JDK1.2>
内部使用动态对象数组，在new初始化的时候，创建一个空的数组。add第一个元素的时候，使用Arrays.copyOf()
扩充这个数组的容量为10的新数组。之后的扩充算法：原来数组的大小+原来数组大小的一半。
因为数组的多次扩充会有性能损耗，所以建议初始化ArrayList的时候，设定初始容量。
它线程不安全，适合单线程使用。

Vector<JDK1.0>
内部也使用动态对象数组，new初始化的时候，创建了初始容量为10的数组，默认增量为0
扩充算法：
当增量为0的时候，扩充为原来大小的2倍
当增量不为0的时候，扩充为原来大小+增量
也不适合插入和删除操作
线程安全，适合多线程操作。单线程操作效率低


LinkedList
采用双向链表的数据结构，适合插入和删除操作，线程不安全
实现了Deque Queue接口，实现了队列和栈的功能


对于上面几种结合的选用：
1.安全性   ArrayList也可以通过Collections工具类变为线程安全的。使用场景较多，应该尽量不用Vector
2.常用于遍历操作还是删除、出入操作


-------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------

Set接口的三个子类：存储不重复的元素，最多一个null
1.HashSet
2.TreeSet
3.LinkedHashSet


HashSet:
内部由散列表（或者叫哈希算法 HashMap）实现，new HashSet()的时候，内部直接new HashMap(),添加元素的
时候，把元素当作HashMap的key存储，value使用固定的Object对象。排除重复方法是通过重写 hashCode() 和equals()方法实现的。
equals()方法默认比较的是内存地址

HashMap 实现原理：数组+链表 。数组中的元素以链表的形式存储

在Java的集合中，判断对象是否相等分为两步：
1.hashCode() 是否相等  HashCode相等的元素也不一定是同一对象，因为hash值为int类型，有边界，会溢出。
另外，在hashMap内部做完HashCode()之后还要取绝对值
2.equals()

所以，自定义对象要认为属性都相等时为同一个对象，必须重写hashCode() equals()










