Map:  因为不能存在相同的key，所以作为key的对象必须实现hashCode() equals()方法
1.HashMap
2.TreeMap
3.LinkedHashMap

遍历的方法总结： map存储的时候，允许有null键和null值
1.getKey(key) --->  value
2.map.entrySet()  -----> Set<Map.Entry<K,V>>   entry.getKey() entry.getValue  ,
实际上map的key，value是存储在这个entry中的
3.map.keySet()  ---> key的集合
4.map.values()  ---> value的集合
5.foreach()  配合lambda表达式



--------------------------------------------------------------------------------
HashMap:

原理：
基于哈希表（数组<Node数组>+链表），默认容量16，加载因子 0.75
有提供带这两个参数的构造方法接口
jdk1.8之后在链表的基础上，链表上存储的容量>8的时候，会使用红黑树（二叉树的一种），Node变为TreeNode
保证了树左右两端的均衡负载

加载因子实际机存储的元素数量与map容量的比值，当存储的元素数量大于这个比值的时候，map会重新散列，扩大容量，当然这个过程
很耗费性能

把key对象通过hash方法计算hash值，然后用这个hash值取余map的容量，来决定元素在数组中的位置
当这个位置存在多个对象的时候，使用双向链表结构存储。当链表的长度大于8的时候，使用红黑树代替。达到
便于查找。数据量越大，性能越明显

扩充原理：
当数组的容量大于加载因子的时候，数组需要扩充为当前容量的2倍，即容量增加一倍。这样，会触发重新散列，
即重新计算每个元素在数组中的存储位置

HashMap线程不安全，适合单线程使用
----------------------------------------------------------------------------------
HashTable 始于jdk1.0
内部使用的是基于哈希表Entry[] 初始容量11，加载因子0.75
扩充方式：原来容量大小*2+1
它是线程安全的，没有用到二叉树。不建议使用
-----------------------------------------------------------------------------------
LinkedHashMap
 哈希表+链表，使用双重链表来维护元素的插入顺序

---------------------------------------------------------------------------------
TreeMap
基于红黑树（平衡二叉树），保证了插入顺序。内部使用Entry。自定义对象的key需要实现Comnparator接口
当key相同的时候，value值被替换
----------------------------------------------------------------------------------
常见的数据结构：
数组 链表 二叉树 栈 队列 哈希表


----------------------------------------------------------------------------------