Map:
1.HashMap
2.TreeMap
3.LinkedHashMap

遍历的方法总结： map存储的时候，允许有null键和null值
1.getKey(key) --->  value
2.map.entrySet()  -----> Set<Map.Entry<K,V>>   entry.getKey() entry.getValue  ,
实际上map的key，value是存储在这个entry中的
3.map.keySet()  ---> key的集合
4.map.values()  ---> value的集合
5.foreach()  配合lambda表达式



--------------------------------------------------------------------------------
HashMap:

原理：
基于哈希表（数组<Node数组>+链表），默认容量16，加载因子 0.75
有提供带这两个参数的构造方法接口
jdk1.8之后在链表的基础上，链表上存储的容量>8的时候，会使用红黑树（二叉树的一种），Node变为TreeNode
保证了树左右两端的均衡负载

加载因子实际机存储的元素数量与map容量的比值，当存储的元素数量大于这个比值的时候，map会重新散列，扩大容量，当然这个过程
很耗费性能

把key对象通过hash方法计算hash值，然后用这个hash值取余map的容量，来决定元素在数组中的位置
当这个位置存在多个对象的时候，使用双向链表结构存储。当链表的长度大于8的时候，使用红黑树代替。达到
便于查找。数据量越大，性能越明显

扩充原理：
当数组的容量大于加载因子的时候，数组需要扩充为当前容量的2倍，即容量增加一倍。这样，会触发重新散列，
即重新计算每个元素在数组中的存储位置

HashMap线程不安全，适合单线程使用